EL enunciado nos explica que tenemos que hacer algo con un archivo core dump.

Lo descargamos y lo primero que hacemos es ejecutar file sobre este archivo para entender mejor sus detalles.

$ file core
core: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from './segfault', real uid: 1000, effective uid: 1000, real gid: 1000, effective gid: 1000, execfn: './segfault', platform: 'x86_64'


Lo que mas llama la atencion es que el archivo core se producjo por un segmentation fualt, es decir se intento acceder a una posicion de memoria sobre la cual no se tiene permiso.
Lo siguient eque hice fue inspeccionar con pwn-gdb el core con el fin de entender que estaba pasando cuando se produjo el error.

$ sudo gdb -c core
[sudo] password for ar70n:
GNU gdb (Debian 13.2-1+b1) 13.2
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word".
pwndbg: loaded 157 pwndbg commands and 47 shell commands. Type pwndbg [--shell | --all] [filter] for a list.
pwndbg: created $rebase, $base, $ida GDB functions (can be used with print/break)

warning: Can't open file /home/ubuntu/shared/CTF/f100/segfault during file-backed mapping note processing
[New LWP 2086]
Core was generated by `./segfault'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000000000400b20 in ?? ()
------- tip of the day (disable with set show-tips off) -------
If you want Pwndbg to clear screen on each command (but still save previous output in history) use set context-clear-screen on
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
────────────────────────────────────────────────────────────────────[ REGISTERS / show-flags off / show-compact-regs off ]────────────────────────────────────────────────────────────────────
 RAX  0x8188008f
 RBX  0x188009d ◂— 0x72 /* 'r' */
 RCX  0x74
 RDX  0
 RDI  0x1880090 ◂— 'not~the~answer'
 RSI  0x4a4928 ◂— add byte ptr [rax], al
 R8   0
 R9   0x187c880 ◂— 0x187c880
 R10  0x6ce868 —▸ 0x6ce858 —▸ 0x18800a0 ◂— 0
 R11  0xe
 R12  0x4016b0 ◂— add byte ptr [rax], al
 R13  0x401740 ◂— add byte ptr [rax], al
 R14  0
 R15  0
 RBP  0x7ffd39be6e80 —▸ 0x6ce018 —▸ 0x43d9a0 ◂— add byte ptr [rax], al
 RSP  0x7ffd39be6e30 —▸ 0x7ffd39be6fc8 —▸ 0x7ffd39be87da ◂— './segfault'
 RIP  0x400b20 ◂— mov byte ptr [rax], 0
─────────────────────────────────────────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]─────────────────────────────────────────────────────────────────────────────
 ► 0x400b20    mov    byte ptr [rax], 0               <Cannot dereference [0x8188008f]>
   0x400b23    mov    eax, 0                          EAX => 0
   0x400b28    mov    rbx, qword ptr [rbp - 0x18]
   0x400b2c    xor    rbx, qword ptr fs:[0x28]
   0x400b35    je     0x400b3c                    <0x400b3c>

   0x400b37    call   0x446870                    <0x446870>

   0x400b3c    add    rsp, 0x48
   0x400b40    pop    rbx
   0x400b41    pop    rbp
   0x400b42    ret

   0x400b43    nop    word ptr cs:[rax + rax]
──────────────────────────────────────────────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────────────────────────────────────────────
00:0000│ rsp 0x7ffd39be6e30 —▸ 0x7ffd39be6fc8 —▸ 0x7ffd39be87da ◂— './segfault'
01:0008│-048 0x7ffd39be6e38 ◂— 0x100400650
02:0010│-040 0x7ffd39be6e40 ◂— 0xe0000000e
03:0018│-038 0x7ffd39be6e48 —▸ 0x187f000 ◂— 'not~the~answer'
04:0020│-030 0x7ffd39be6e50 ◂— 0x78 /* 'x' */
05:0028│-028 0x7ffd39be6e58 ◂— 0xf
06:0030│-020 0x7ffd39be6e60 —▸ 0x1880090 ◂— 'not~the~answer'
07:0038│-018 0x7ffd39be6e68 ◂— 0x29762a372172d00
────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────────────────────────────────────────────
 ► 0         0x400b20
   1   0x7ffd39be6fc8
   2      0x100400650
   3      0xe0000000e
   4        0x187f000
   5             0x78
   6              0xf
   7        0x1880090


Este es el contexto que tenemos:
La línea #0 0x0000000000400b20 in ?? () indica que el error ocurrió en la dirección de memoria 0x0000000000400b20, pero gdb no puede determinar a qué función corresponde esa dirección porque no tiene el binario original.

La sección de registros muestra el estado de los registros en el momento del error. Por ejemplo, el registro RAX contiene el valor 0x8188008f, que es probablemente una dirección de memoria inválida por que es más alta de lo habitual, lo que podría haber causado el segmentation fault.

La sección de desensamblado muestra las instrucciones que se estaban ejecutando en el momento del error. La instrucción mov byte ptr [rax], 0 intenta escribir el valor 0 en la dirección de memoria contenida en RAX, que como mencioné antes, parece ser inválida.

Finalmente, la sección de backtrace muestra la pila de llamadas en el momento del error. Sin embargo, sin el binario original, gdb no puede determinar a qué funciones corresponden estas direcciones de memoria.

Notamos que el registro RDI contiene la dirección de la cadena 'not~the~answer', que podría ser una pista. También, el registro RBX contiene el valor 0x188009d, que corresponde al carácter 'r'. Esto es lo que me ha parecido más interesante. 

Como no se me ocurre como seguir pruebo a ejecutar el comando strings sobre el core a ver si hay algo más de informacion:

$ strings core
CORE
CORE
segfault
./segfault
IGISCORE
CORE
ELIFCORE
/home/ubuntu/shared/CTF/f100/segfault
/home/ubuntu/shared/CTF/f100/segfault
CORE
t#hean;SW.er
LINUX
t#hean;SW.er
ATUS
[]A\
UH-P
u"UH
AVAU
ATUI
HcD$
uUdH
D$hdH
D$pH
D$ dH
AUAT1
Genu
ntel
ineI
Auth@
cAMD
enti
/home/ubuntu/shared/CTF/f100
linux-vdso.so.1
tls//
password:
not~the~answer
not~the~answer
not~the~answer
/home/ubuntu/shared/CTF/f100/segfault
9=bF
x86_64
./segfault
LESSOPEN=| /usr/bin/lesspipe %s
MAIL=/var/mail/ubuntu
....


De aqui lo mas interesante es "password:", la siguiente linea es not~the~answer por lo que confunde un poco pero si nos fijamos más arriba tenemos el string: "t#hean;SW.er"
Como no sabía por donde seguir probe con este strong que resulto siendo la flag.
